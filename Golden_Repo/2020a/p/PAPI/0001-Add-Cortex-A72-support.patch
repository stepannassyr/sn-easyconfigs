From 7eadf6137da648f291525938cdeeb2f618a28380 Mon Sep 17 00:00:00 2001
From: Stepan Nassyr <s.nassyr@fz-juelich.de>
Date: Mon, 28 Oct 2019 17:58:04 +0100
Subject: [PATCH 1/2] Add Cortex-A72 support

---
 src/libpfm4/include/perfmon/pfmlib.h           |   1 +
 src/libpfm4/lib/Makefile                       |   4 +-
 src/libpfm4/lib/events/arm_cortex_a72_events.h | 443 +++++++++++++++++++++++++
 src/libpfm4/lib/pfmlib_arm_armv8.c             |  42 +++
 src/libpfm4/lib/pfmlib_common.c                |   2 +
 src/libpfm4/lib/pfmlib_priv.h                  |   1 +
 src/libpfm4/tests/validate_arm.c               |  28 ++
 src/libpfm4/tests/validate_arm64.c             |  28 ++
 src/papi_events.csv                            |  23 ++
 9 files changed, 571 insertions(+), 1 deletion(-)
 create mode 100644 src/libpfm4/lib/events/arm_cortex_a72_events.h

diff --git a/src/libpfm4/include/perfmon/pfmlib.h b/src/libpfm4/include/perfmon/pfmlib.h
index bd6f935..ebb99f3 100644
--- a/src/libpfm4/include/perfmon/pfmlib.h
+++ b/src/libpfm4/include/perfmon/pfmlib.h
@@ -239,6 +239,7 @@ typedef enum {
 
 	PFM_PMU_S390X_CPUM_SF,		/* s390x: CPU-M sampling facility */
 
+	PFM_PMU_ARM_CORTEX_A72,		/* ARM Cortex A72 (ARMv8) */
 	PFM_PMU_ARM_CORTEX_A57,		/* ARM Cortex A57 (ARMv8) */
 	PFM_PMU_ARM_CORTEX_A53,		/* ARM Cortex A53 (ARMv8) */
 
diff --git a/src/libpfm4/lib/Makefile b/src/libpfm4/lib/Makefile
index 2eb3ebb..7bae870 100644
--- a/src/libpfm4/lib/Makefile
+++ b/src/libpfm4/lib/Makefile
@@ -358,11 +358,13 @@ INC_ARM=pfmlib_arm_priv.h			\
 	events/arm_cortex_a8_events.h		\
 	events/arm_cortex_a9_events.h		\
 	events/arm_cortex_a15_events.h		\
+	events/arm_cortex_a72_events.h		\
 	events/arm_cortex_a57_events.h		\
 	events/arm_cortex_a53_events.h		\
 	events/arm_cavium_tx2_events.h
 
-INC_ARM64=events/arm_cortex_a57_events.h	\
+INC_ARM64=events/arm_cortex_a72_events.h	\
+	  events/arm_cortex_a57_events.h	\
 	  events/arm_cortex_a53_events.h	\
 	  events/arm_cavium_tx2_events.h
 
diff --git a/src/libpfm4/lib/events/arm_cortex_a72_events.h b/src/libpfm4/lib/events/arm_cortex_a72_events.h
new file mode 100644
index 0000000..4b0f4e8
--- /dev/null
+++ b/src/libpfm4/lib/events/arm_cortex_a72_events.h
@@ -0,0 +1,443 @@
+/*
+ * Copyright (c) 2014 Google Inc. All rights reserved
+ * Contributed by Stephane Eranian for Cortex A57 <eranian@gmail.com>
+ *
+ * Copyright (c) 2019 Forschungszentrum Juelich.
+ * Adapted for Cortex-A72 by Stepan Nassyr <s.nassyr@fz-juelich.de>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+ * of the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+ * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Cortex A72 
+ * based on Table 11-24 from the "ARM Cortex-A72 MPCore Processor Technical Reference Manual"
+ */
+
+static const arm_entry_t arm_cortex_a72_pe[]={
+	{.name = "SW_INCR",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x00,
+	 .desc = "Instruction architecturally executed (condition check pass) Software increment"
+	},
+	{.name = "L1I_CACHE_REFILL",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x01,
+	 .desc = "Level 1 instruction cache refill"
+	},
+	{.name = "L1I_TLB_REFILL",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x02,
+	 .desc = "Level 1 instruction TLB refill"
+	},
+	{.name = "L1D_CACHE_REFILL",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x03,
+	 .desc = "Level 1 data cache refill"
+	},
+	{.name = "L1D_CACHE_ACCESS",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x04,
+	 .desc = "Level 1 data cache access"
+	},
+	{.name = "L1D_TLB_REFILL",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x05,
+	 .desc = "Level 1 data TLB refill"
+	},
+
+	{.name = "INST_RETIRED",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x08,
+	 .desc = "Instruction architecturally executed"
+	},
+	{.name = "EXCEPTION_TAKEN",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x09,
+	 .desc = "Exception taken"
+	},
+	{.name = "EXCEPTION_RETURN",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x0a,
+	 .desc = "Instruction architecturally executed (condition check pass) Exception return"
+	},
+	{.name = "CID_WRITE_RETIRED",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x0b,
+	 .desc = "Instruction architecturally executed (condition check pass)  Write to CONTEXTIDR"
+	},
+
+	{.name = "BRANCH_MISPRED",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x10,
+	 .desc = "Mispredicted or not predicted branch speculatively executed"
+	},
+	{.name = "CPU_CYCLES",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x11,
+	 .desc = "Cycles"
+	},
+	{.name = "BRANCH_PRED",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x12,
+	 .desc = "Predictable branch speculatively executed"
+	},
+	{.name = "DATA_MEM_ACCESS",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x13,
+	 .desc = "Data memory access"
+	},
+	{.name = "L1I_CACHE_ACCESS",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x14,
+	 .desc = "Level 1 instruction cache access"
+	},
+	{.name = "L1D_CACHE_WB",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x15,
+	 .desc = "Level 1 data cache WriteBack"
+	},
+	{.name = "L2D_CACHE_ACCESS",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x16,
+	 .desc = "Level 2 data cache access"
+	},
+	{.name = "L2D_CACHE_REFILL",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x17,
+	 .desc = "Level 2 data cache refill"
+	},
+	{.name = "L2D_CACHE_WB",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x18,
+	 .desc = "Level 2 data cache WriteBack"
+	},
+	{.name = "BUS_ACCESS",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x19,
+	 .desc = "Bus access"
+	},
+	{.name = "LOCAL_MEMORY_ERROR",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x1a,
+	 .desc = "Local memory error"
+	},
+	{.name = "INST_SPEC_EXEC",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x1b,
+	 .desc = "Instruction speculatively executed"
+	},
+	{.name = "TTBR_WRITE_RETIRED",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x1c,
+	 .desc = "Instruction architecturally executed (condition check pass)  Write to translation table base"
+	},
+	{.name = "BUS_CYCLES",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x1d,
+	 .desc = "Bus cycle"
+	},
+	{.name = "L1D_READ_ACCESS",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x40,
+	 .desc = "Level 1 data cache read access"
+	},
+	{.name = "L1D_WRITE_ACCESS",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x41,
+	 .desc = "Level 1 data cache write access"
+	},
+	{.name = "L1D_READ_REFILL",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x42,
+	 .desc = "Level 1 data cache read refill"
+	},
+	{.name = "L1D_WRITE_REFILL",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x43,
+	 .desc = "Level 1 data cache write refill"
+	},
+	{.name = "L1D_WB_VICTIM",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x46,
+	 .desc = "Level 1 data cache writeback victim"
+	},
+	{.name = "L1D_WB_CLEAN_COHERENCY",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x47,
+	 .desc = "Level 1 data cache writeback cleaning and coherency"
+	},
+	{.name = "L1D_INVALIDATE",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x48,
+	 .desc = "Level 1 data cache invalidate"
+	},
+	{.name = "L1D_TLB_READ_REFILL",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x4c,
+	 .desc = "Level 1 data TLB read refill"
+	},
+	{.name = "L1D_TLB_WRITE_REFILL",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x4d,
+	 .desc = "Level 1 data TLB write refill"
+	},
+	{.name = "L2D_READ_ACCESS",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x50,
+	 .desc = "Level 2 data cache read access"
+	},
+	{.name = "L2D_WRITE_ACCESS",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x51,
+	 .desc = "Level 2 data cache write access"
+	},
+	{.name = "L2D_READ_REFILL",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x52,
+	 .desc = "Level 2 data cache read refill"
+	},
+	{.name = "L2D_WRITE_REFILL",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x53,
+	 .desc = "Level 2 data cache write refill"
+	},
+	{.name = "L2D_WB_VICTIM",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x56,
+	 .desc = "Level 2 data cache writeback victim"
+	},
+	{.name = "L2D_WB_CLEAN_COHERENCY",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x57,
+	 .desc = "Level 2 data cache writeback cleaning and coherency"
+	},
+	{.name = "L2D_INVALIDATE",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x58,
+	 .desc = "Level 2 data cache invalidate"
+	},
+	{.name = "BUS_READ_ACCESS",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x60,
+	 .desc = "Bus read access"
+	},
+	{.name = "BUS_WRITE_ACCESS",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x61,
+	 .desc = "Bus write access"
+	},
+	{.name = "BUS_NORMAL_ACCESS",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x62,
+	 .desc = "Bus normal access"
+	},
+	{.name = "BUS_NOT_NORMAL_ACCESS",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x63,
+	 .desc = "Bus not normal access"
+	},
+	{.name = "BUS_NORMAL_ACCESS_2",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x64,
+	 .desc = "Bus normal access"
+	},
+	{.name = "BUS_PERIPH_ACCESS",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x65,
+	 .desc = "Bus peripheral access"
+	},
+	{.name = "DATA_MEM_READ_ACCESS",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x66,
+	 .desc = "Data memory read access"
+	},
+	{.name = "DATA_MEM_WRITE_ACCESS",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x67,
+	 .desc = "Data memory write access"
+	},
+	{.name = "UNALIGNED_READ_ACCESS",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x68,
+	 .desc = "Unaligned read access"
+	},
+	{.name = "UNALIGNED_WRITE_ACCESS",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x69,
+	 .desc = "Unaligned read access"
+	},
+	{.name = "UNALIGNED_ACCESS",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x6a,
+	 .desc = "Unaligned access"
+	},
+	{.name = "INST_SPEC_EXEC_LDREX",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x6c,
+	 .desc = "LDREX exclusive instruction speculatively executed"
+	},
+	{.name = "INST_SPEC_EXEC_STREX_PASS",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x6d,
+	 .desc = "STREX pass exclusive instruction speculatively executed"
+	},
+	{.name = "INST_SPEC_EXEC_STREX_FAIL",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x6e,
+	 .desc = "STREX fail exclusive instruction speculatively executed"
+	},
+	{.name = "INST_SPEC_EXEC_LOAD",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x70,
+	 .desc = "Load instruction speculatively executed"
+	},
+	{.name = "INST_SPEC_EXEC_STORE",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x71,
+	 .desc = "Store instruction speculatively executed"
+	},
+	{.name = "INST_SPEC_EXEC_LOAD_STORE",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x72,
+	 .desc = "Load or store instruction speculatively executed"
+	},
+	{.name = "INST_SPEC_EXEC_INTEGER_INST",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x73,
+	 .desc = "Integer data processing instruction speculatively executed"
+	},
+	{.name = "INST_SPEC_EXEC_SIMD",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x74,
+	 .desc = "Advanced SIMD instruction speculatively executed"
+	},
+	{.name = "INST_SPEC_EXEC_VFP",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x75,
+	 .desc = "VFP instruction speculatively executed"
+	},
+	{.name = "INST_SPEC_EXEC_SOFT_PC",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x76,
+	 .desc = "Software of the PC instruction speculatively executed"
+	},
+	{.name = "BRANCH_SPEC_EXEC_IMM_BRANCH",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x78,
+	 .desc = "Immediate branch speculatively executed"
+	},
+	{.name = "BRANCH_SPEC_EXEC_RET",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x79,
+	 .desc = "Return branch speculatively executed"
+	},
+	{.name = "BRANCH_SPEC_EXEC_IND",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x7a,
+	 .desc = "Indirect branch speculatively executed"
+	},
+	{.name = "BARRIER_SPEC_EXEC_ISB",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x7c,
+	 .desc = "ISB barrier speculatively executed"
+	},
+	{.name = "BARRIER_SPEC_EXEC_DSB",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x7d,
+	 .desc = "DSB barrier speculatively executed"
+	},
+	{.name = "BARRIER_SPEC_EXEC_DMB",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x7e,
+	 .desc = "DMB barrier speculatively executed"
+	},
+	{.name = "EXCEPTION_UNDEF",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x81,
+	 .desc = "Exception taken, other synchronous"
+	},
+	{.name = "EXCEPTION_SVC",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x82,
+	 .desc = "Exception taken, supervisor call"
+	},
+	{.name = "EXCEPTION_PABORT",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x83,
+	 .desc = "Exception taken, instruction abort"
+	},
+	{.name = "EXCEPTION_DABORT",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x84,
+	 .desc = "Exception taken, data abort or SError"
+	},
+	{.name = "EXCEPTION_IRQ",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x86,
+	 .desc = "Exception taken, irq"
+	},
+	{.name = "EXCEPTION_FIQ",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x87,
+	 .desc = "Exception taken, irq"
+	},
+	{.name = "EXCEPTION_SMC",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x88,
+	 .desc = "Exception taken, secure monitor call"
+	},
+	{.name = "EXCEPTION_HVC",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x8a,
+	 .desc = "Exception taken, hypervisor call"
+	},
+	{.name = "EXCEPTION_TRAP_PABORT",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x8b,
+	 .desc = "Exception taken, instruction abort not taken locally"
+	},
+	{.name = "EXCEPTION_TRAP_DABORT",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x8c,
+	 .desc = "Exception taken, data abort or SError not taken locally"
+	},
+	{.name = "EXCEPTION_TRAP_OTHER",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x8d,
+	 .desc = "Exception taken, other traps not taken locally"
+	},
+	{.name = "EXCEPTION_TRAP_IRQ",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x8e,
+	 .desc = "Exception taken, irq not taken locally"
+	},
+	{.name = "EXCEPTION_TRAP_FIQ",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x8f,
+	 .desc = "Exception taken, fiq not taken locally"
+	},
+	{.name = "RC_LD_SPEC",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x90,
+	 .desc = "Release consistency instruction speculatively executed (load-acquire)",
+	},
+	{.name = "RC_ST_SPEC",
+	 .modmsk = ARMV8_ATTRS,
+	 .code = 0x91,
+	 .desc = "Release consistency instruction speculatively executed (store-release)",
+	},
+	/* END Cortex A47 specific events */
+};
diff --git a/src/libpfm4/lib/pfmlib_arm_armv8.c b/src/libpfm4/lib/pfmlib_arm_armv8.c
index 0a3313f..a782521 100644
--- a/src/libpfm4/lib/pfmlib_arm_armv8.c
+++ b/src/libpfm4/lib/pfmlib_arm_armv8.c
@@ -30,12 +30,29 @@
 #include "pfmlib_priv.h"			/* library private */
 #include "pfmlib_arm_priv.h"
 
+#include "events/arm_cortex_a72_events.h"    /* A72 event tables */
 #include "events/arm_cortex_a57_events.h"    /* A57 event tables */
 #include "events/arm_cortex_a53_events.h"    /* A53 event tables */
 #include "events/arm_xgene_events.h"         /* Applied Micro X-Gene tables */
 #include "events/arm_cavium_tx2_events.h"    /* Cavium ThunderX2 tables */
 
 static int
+pfm_arm_detect_cortex_a72(void *this)
+{
+	int ret;
+
+	ret = pfm_arm_detect(this);
+	if (ret != PFM_SUCCESS)
+		return PFM_ERR_NOTSUPP;
+
+	if ((pfm_arm_cfg.implementer == 0x41) && /* ARM */
+		(pfm_arm_cfg.part == 0xd08)) { /* Cortex A72 */ 
+			return PFM_SUCCESS;
+	}
+	return PFM_ERR_NOTSUPP;
+}
+
+static int
 pfm_arm_detect_cortex_a57(void *this)
 {
 	int ret;
@@ -103,6 +120,31 @@ pfm_arm_detect_thunderx2(void *this)
 	return PFM_ERR_NOTSUPP;
 }
 
+/* ARM Cortex A72 support */
+pfmlib_pmu_t arm_cortex_a72_support={
+	.desc			= "ARM Cortex A72",
+	.name			= "arm_ac72",
+	.pmu			= PFM_PMU_ARM_CORTEX_A72,
+	.pme_count		= LIBPFM_ARRAY_SIZE(arm_cortex_a72_pe),
+	.type			= PFM_PMU_TYPE_CORE,
+	.pe			= arm_cortex_a72_pe,
+
+	.pmu_detect		= pfm_arm_detect_cortex_a72,
+	.max_encoding		= 1,
+	.num_cntrs		= 6,
+
+	.get_event_encoding[PFM_OS_NONE] = pfm_arm_get_encoding,
+	 PFMLIB_ENCODE_PERF(pfm_arm_get_perf_encoding),
+	.get_event_first	= pfm_arm_get_event_first,
+	.get_event_next		= pfm_arm_get_event_next,
+	.event_is_valid		= pfm_arm_event_is_valid,
+	.validate_table		= pfm_arm_validate_table,
+	.get_event_info		= pfm_arm_get_event_info,
+	.get_event_attr_info	= pfm_arm_get_event_attr_info,
+	 PFMLIB_VALID_PERF_PATTRS(pfm_arm_perf_validate_pattrs),
+	.get_event_nattrs	= pfm_arm_get_event_nattrs,
+};
+
 /* ARM Cortex A57 support */
 pfmlib_pmu_t arm_cortex_a57_support={
 	.desc			= "ARM Cortex A57",
diff --git a/src/libpfm4/lib/pfmlib_common.c b/src/libpfm4/lib/pfmlib_common.c
index 688edb6..482218e 100644
--- a/src/libpfm4/lib/pfmlib_common.c
+++ b/src/libpfm4/lib/pfmlib_common.c
@@ -480,12 +480,14 @@ static pfmlib_pmu_t *pfmlib_pmus[]=
 	&arm_cortex_a15_support,
 	&arm_1176_support,
 	&arm_qcom_krait_support,
+	&arm_cortex_a72_support,
 	&arm_cortex_a57_support,
 	&arm_cortex_a53_support,
 	&arm_xgene_support,
 	&arm_thunderx2_support,
 #endif
 #ifdef CONFIG_PFMLIB_ARCH_ARM64
+	&arm_cortex_a72_support,
 	&arm_cortex_a57_support,
 	&arm_cortex_a53_support,
 	&arm_xgene_support,
diff --git a/src/libpfm4/lib/pfmlib_priv.h b/src/libpfm4/lib/pfmlib_priv.h
index fe13351..47dd70c 100644
--- a/src/libpfm4/lib/pfmlib_priv.h
+++ b/src/libpfm4/lib/pfmlib_priv.h
@@ -640,6 +640,7 @@ extern pfmlib_pmu_t arm_cortex_a9_support;
 extern pfmlib_pmu_t arm_cortex_a15_support;
 extern pfmlib_pmu_t arm_1176_support;
 extern pfmlib_pmu_t arm_qcom_krait_support;
+extern pfmlib_pmu_t arm_cortex_a72_support;
 extern pfmlib_pmu_t arm_cortex_a57_support;
 extern pfmlib_pmu_t arm_cortex_a53_support;
 extern pfmlib_pmu_t arm_xgene_support;
diff --git a/src/libpfm4/tests/validate_arm.c b/src/libpfm4/tests/validate_arm.c
index db0439f..5b7e840 100644
--- a/src/libpfm4/tests/validate_arm.c
+++ b/src/libpfm4/tests/validate_arm.c
@@ -189,6 +189,34 @@ static const test_event_t arm_test_events[]={
 	  .fstr = "qcom_krait::CPU_CYCLES:k=0:u=1:hv=0",
 	},
 	{ SRC_LINE,
+	  .name = "arm_ac72::CPU_CYCLES",
+	  .ret  = PFM_SUCCESS,
+	  .count = 1,
+	  .codes[0] = 0x8000011,
+	  .fstr = "arm_ac72::CPU_CYCLES:k=1:u=1:hv=0",
+	},
+	{ SRC_LINE,
+	  .name = "arm_ac72::CPU_CYCLES:k",
+	  .ret  = PFM_SUCCESS,
+	  .count = 1,
+	  .codes[0] = 0x88000011,
+	  .fstr = "arm_ac72::CPU_CYCLES:k=1:u=0:hv=0",
+	},
+	{ SRC_LINE,
+	  .name = "arm_ac72::CPU_CYCLES:k:u",
+	  .ret  = PFM_SUCCESS,
+	  .count = 1,
+	  .codes[0] = 0x8000011,
+	  .fstr = "arm_ac72::CPU_CYCLES:k=1:u=1:hv=0",
+	},
+	{ SRC_LINE,
+	  .name = "arm_ac72::INST_RETIRED",
+	  .ret  = PFM_SUCCESS,
+	  .count = 1,
+	  .codes[0] = 0x8000008,
+	  .fstr = "arm_ac72::INST_RETIRED:k=1:u=1:hv=0",
+	},
+	{ SRC_LINE,
 	  .name = "arm_ac57::CPU_CYCLES",
 	  .ret  = PFM_SUCCESS,
 	  .count = 1,
diff --git a/src/libpfm4/tests/validate_arm64.c b/src/libpfm4/tests/validate_arm64.c
index f7f021a..3a2a2c3 100644
--- a/src/libpfm4/tests/validate_arm64.c
+++ b/src/libpfm4/tests/validate_arm64.c
@@ -45,6 +45,34 @@ typedef struct {
 
 static const test_event_t arm64_test_events[]={
 	{ SRC_LINE,
+	  .name = "arm_ac72::CPU_CYCLES",
+	  .ret  = PFM_SUCCESS,
+	  .count = 1,
+	  .codes[0] = 0x8000011,
+	  .fstr = "arm_ac72::CPU_CYCLES:k=1:u=1:hv=0",
+	},
+	{ SRC_LINE,
+	  .name = "arm_ac72::CPU_CYCLES:k",
+	  .ret  = PFM_SUCCESS,
+	  .count = 1,
+	  .codes[0] = 0x88000011,
+	  .fstr = "arm_ac72::CPU_CYCLES:k=1:u=0:hv=0",
+	},
+	{ SRC_LINE,
+	  .name = "arm_ac72::CPU_CYCLES:k:u",
+	  .ret  = PFM_SUCCESS,
+	  .count = 1,
+	  .codes[0] = 0x8000011,
+	  .fstr = "arm_ac72::CPU_CYCLES:k=1:u=1:hv=0",
+	},
+	{ SRC_LINE,
+	  .name = "arm_ac72::INST_RETIRED",
+	  .ret  = PFM_SUCCESS,
+	  .count = 1,
+	  .codes[0] = 0x8000008,
+	  .fstr = "arm_ac72::INST_RETIRED:k=1:u=1:hv=0",
+	},
+	{ SRC_LINE,
 	  .name = "arm_ac57::CPU_CYCLES",
 	  .ret  = PFM_SUCCESS,
 	  .count = 1,
diff --git a/src/papi_events.csv b/src/papi_events.csv
index 8df7486..0f01cb9 100644
--- a/src/papi_events.csv
+++ b/src/papi_events.csv
@@ -1769,6 +1769,29 @@ PRESET,PAPI_L1_DCM,NOT_DERIVED,DCACHE_REFILL
 PRESET,PAPI_L1_ICM,NOT_DERIVED,IFETCH_MISS
 #
 CPU,arm_ac15
+CPU,arm_ac72
+#
+PRESET,PAPI_TOT_INS,NOT_DERIVED,INST_RETIRED
+PRESET,PAPI_TOT_IIS,NOT_DERIVED,INST_SPEC_EXEC
+PRESET,PAPI_TOT_CYC,NOT_DERIVED,CPU_CYCLES
+PRESET,PAPI_FP_INS,NOT_DERIVED,INST_SPEC_EXEC_VFP
+PRESET,PAPI_VEC_INS,NOT_DERIVED,INST_SPEC_EXEC_SIMD
+PRESET,PAPI_BR_INS,NOT_DERIVED,INST_SPEC_EXEC_SOFT_PC
+PRESET,PAPI_BR_MSP,NOT_DERIVED,BRANCH_MISPRED
+PRESET,PAPI_LD_INS,NOT_DERIVED,DATA_MEM_READ_ACCESS
+PRESET,PAPI_SR_INS,NOT_DERIVED,DATA_MEM_WRITE_ACCESS
+PRESET,PAPI_L1_DCA,DERIVED_ADD,L1D_READ_ACCESS,L1D_WRITE_ACCESS
+PRESET,PAPI_L1_DCM,DERIVED_ADD,L1D_READ_REFILL,L1D_WRITE_REFILL
+PRESET,PAPI_L1_DCR,NOT_DERIVED,L1D_READ_ACCESS
+PRESET,PAPI_L1_DCW,NOT_DERIVED,L1D_WRITE_ACCESS
+PRESET,PAPI_L1_ICA,NOT_DERIVED,L1I_CACHE_ACCESS
+PRESET,PAPI_L1_ICM,NOT_DERIVED,L1I_CACHE_REFILL
+PRESET,PAPI_L2_DCH,NOT_DERIVED,L2D_CACHE_ACCESS
+PRESET,PAPI_L2_DCM,NOT_DERIVED,L2D_CACHE_REFILL
+PRESET,PAPI_L2_DCR,NOT_DERIVED,L2D_READ_ACCESS
+PRESET,PAPI_L2_DCW,NOT_DERIVED,L2D_WRITE_ACCESS
+PRESET,PAPI_L2_LDM,NOT_DERIVED,L2D_READ_REFILL
+PRESET,PAPI_L2_STM,NOT_DERIVED,L2D_WRITE_REFILL
 CPU,arm_ac57
 #
 PRESET,PAPI_TOT_INS,NOT_DERIVED,INST_RETIRED
-- 
1.8.3.1

